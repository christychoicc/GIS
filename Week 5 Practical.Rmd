---
title: "week_5_practical"
output: html_document
---

# Chapter 5 - Map Making

Practical: Compare Airbnbs and Hotels across London Boroughs

## Clear Memory First !!

```{r}
rm(list = ls()) #removes all objects from workspace 
gc() #clear memory
```

## 5.5. Download Data

1.  OSM

    Go to the Geofabrik download server [website](http://download.geofabrik.de/) \> Europe \> United Kingdom \> England \> Greater London \> Download greater-london-latest-free.shp.zip

2.  London Boroughs

    To get the data go to [the London data store](https://data.london.gov.uk/) \> Search Statistical GIS Boundary Files For London \> Download statistical-gis-boundaries-london.zip

3.  World Cities

    Download them from the [ArcGIS HUB](https://hub.arcgis.com/datasets/6996f03a1b364dbab4008d99380370ed_0) \> Download \> Shapefile

4.  UK Outline

    Download [GADM data for the UK](https://gadm.org/download_country.html)

5.  Airbnb

    Download the `listings.csv` from the [inside airbnb website](http://insideairbnb.com/get-the-data.html) for London.

## 5.6. Plan

First, always have a clear aim, draw out what we want our final map to look like!!

Reminder: the task is to ***"Compare the Spatial Patterns of Airbnbs and Hotels across London Boroughs"***

This practical selected boroughs for ease and to show certain concepts:

-   Boroughs are **not** a good spatial unit for this

    -   Boroughs vary hugely in size and populations, so aggregate counts may mislead

    -   e.g. Big/ busy boroughs will always look like they have "more" even if they are not actually more intense

-   Should **never** use count data for mapping!!

    -   Never colour a map with raw totals (just the count) as big/ busy places naturally have bigger totals, looking "more intense" when they are not !!

Ok, so, the plan will be something like this...

![](images/clipboard-1445683016.png)

### Steps of the Plan

1.  Conceptually, think of each section as a separate object, e.g. Hotels will be a London Borough 'sf' object that has a column of Hotels
2.  Wrangle our data to get to that point
    1.  Downloading data
        1.  Hotels and Airbnb Figures
            -   London borough MSOAs (shp)

            -   Airbnbs (csv)

            -   Hotels (shp)
        2.  Study Area Map
            -   Outline of the UK (shp)

            -   UK Cities (shp)
    2.  Setting the CRS and Filtering
        -   Our CRS for the Boroughs needs to be British national grid (BNG)

        -   Filter hotels from the OSM data

        -   Filter equivalent airbnbs (e.g. room_type == ‘Entire home/apt’ & availability_365 ==‘365’)
    3.  Joining and Summing Data
        -   Join the Airbnbs to the MSOAs and sum (i.e. how many are in each MSOA)

        -   Join the Hotels to the MSOAs and sum
    4.  Making Some Maps

## 5.7. CRS and Filter

We have downloaded the data already so we move on to 2. Setting the CRS and Filtering.

Starting with OSM and Airbnb data which we need for our sub figures:

1.  OSM
2.  Airbnb
3.  MSOAs polygons (Middle Layer Super Output Area - used for reporting small area statistics)

**Why this order:**

-   **CRS first** so all spatial operations (point-in-polygon, area calculation) are accurate (meters, not degrees).

-   **Filtering before joins** reduces noise and speeds up spatial joins; also ensures you’re comparing like with like (entire homes vs. hotels).

**What it gives:** Methodologically fair comparison and correct geometry/area calculations for density later.

### Set CRS and Filter

-   We reproject all layers to British National Grid (BNG; EPSG:27700)

    -   Do this first, so that all spatial operations are accurate!!

    -   27700, the BNG, good for UK work and for accurate distances/ areas in meters

-   Filter hotels from OSM

-   Filter Airbnbs to a comparable subset

### OSM Data:

Geofabrik (one of these websites) allows you to download frequently updated shapefiles for various global subdivisions.

```{r}
library(sf) 
library(tidyverse)  

# OSM data   

OSM <- st_read("Week 5 Practical Data/greater-london-251105-free.shp (1)/gis_osm_pois_free_1.shp")%>%   st_transform(., 27700) %>%   #select hotels only   
  filter(fclass =='hotel')
```

### Airbnb Data:

```{r}
# Airbnb Data  

Airbnb <- read_csv("Week 5 Practical Data/listings (4).csv") %>%
  # longitude is considered x value here, latitude is y
  # this step we turn a plain table into a spatial object!! 
  st_as_sf(., coords = c("longitude", "latitude"), 
                   crs = 4326) %>%
                  # crs=4326 tells R what coordinate systems those numbers r in
    st_transform(., 27700)%>%
    #reproject to a different CRS
    #select entire places that are available all year
    filter(room_type == 'Entire home/apt' & availability_365 =='365')

```

### MSOA London Borough (polygons):

The MSOA shapefiles are for actual analysis - the polygons we will join our points to an aggregate within!!

```{r}
#London Borough data is already in 277000
Londonborough <- st_read("Week 5 Practical Data/statistical-gis-boundaries-london (2)/statistical-gis-boundaries-london/ESRI/London_Borough_Excluding_MHW.shp")%>%
  st_transform(., 27700)
```

### World Cities Data (points):

-   Filtering Birmingham, London, Edinburgh

-   An Outline of the UK

```{r}
# Load World Cities 
Worldcities <- st_read("Week 5 Practical Data/World_Cities (2)/World_Cities.shp") %>%   
  st_transform(., 27700)
```

```{r}
# Filter based on key cities (Birmingham, London, Edinburgh) 
Worldcities2 <- Worldcities %>%   
  filter(CNTRY_NAME == 'United Kingdom'&            # take only rows that has United Kingdom in CNTRY_NAME column            
           Worldcities$CITY_NAME == 'Birmingham'|            
           Worldcities$CITY_NAME == 'London'|            
           Worldcities$CITY_NAME == 'Edinburgh')           
          # meaning in Worldcities, reach CITY_NAME for the key cities   


# Load UK Outline and transform 227700 
UK_outline <- st_read("Week 5 Practical Data/gadm41_GBR_shp (1)/gadm41_GBR_0.shp") %>%   
  st_transform(., 27700)
```

## 5.8. Join and Sum

**Why now:** Once points are attributed to polygons, you can roll up counts, then compute **rates** and **ratios**.

**What it gives:** The core comparison table: for each MSOA, how many Airbnbs vs. hotels.

### Join Data

To join 2 spatial features we use - `st_join()`

The output will be a large dataset where:

-   Each hotel will be a new row

-   It will retain the attributes of the hotel data but also append the attribute of the borough

-   `st_join()` defaults to a left join, so in this case the borough data is the left dataset and all the right data has been appended to it. If the left data (borough) had no matches (so no hotels) they would still appear in the final dataset. The default argument for this is `st_intersects` but we will explore this more next week.

Ok, let's do the join (spatially join airbnb and hotels)!!

```{r}
Hotels <- st_join(Londonborough, OSM)

Airbnbs <- st_join(Londonborough, Airbnb)

head(Hotels)
```

### Group and Summarise Data

Now, each hotel/ airbnb is a row and has the borough data appended

We want one row per borough, and the count of the number of hotels/ airbnbs

Therefore, we use g `group_by()`, which is always followed by `summarise()`

-   `group_by()` creates temporary groups, if you were to print the data it would look the same as before just with the number of groups specified

-   `summarise()` takes the groups and provides a summary, here a count per group.

What we have done below is:

1.  . (the dot) getting incoming data from the pipe %\>%
2.  Split data into groups defined by GSS_CODE and NAME
3.  Summarise data (collaspe each group into one row, computing count of rows: n() in that group, name the new column \`Accomodation count\`)
4.  **`n()`** inside `summarise` refers to returning the number of rows in the current group!!

```{r}
Hotels_sum <- Hotels %>%
  # We need to list the columns we want to keep in the summarise
  group_by(., GSS_CODE, NAME) %>%
  # For each group count the number of rows and store in a column called accomodation count
  summarise(`Accomodation count` = n())


Airbnb_sum <- Airbnbs %>%
  group_by(., GSS_CODE, NAME) %>%
  summarise(`Accomodation count` = n())
```

#### Problem with Spatial Join (like a left join):

For boroughs with 0 hotels/ airbnbs, when we group_by and summarise, the borough will always keep at least one row -\> which will return a value of 1 even it is actually 0!!

For Example:

Let’s filter our Hotels object (the one we spatially joined on Bexley, then compare it to the Hotel sum data…

(Chose Bexley as an example as I checked from Hotels, Bexley's whole row is NA NA NA NA)).

```{r}
# the st_join data = 0 Hotels in Bexley
Hotels %>%
  filter(NAME=="Bexley")
```

```{r}
# the group by and summarise data = 1 Hotel in Bexley!
Hotels_sum %>%
  filter(NAME=="Bexley")
```

#### So, How to Fix This ?

We can use a topological relationship!!

More can be read here: <https://postgis.net/workshops/postgis-intro/spatial_relationships.html>

![](images/clipboard-1517386785.png)

Topology is the arrangement of how point, line, and polygon features share geometry — how they relate in space **without caring about exact distances or coordinates**, just their **relative arrangement**. Think “do they touch, overlap, sit inside, or are they separate?”

**Common ones to focus on include:\
***Example: A = Boroughs（倫敦各區 polygon）、B = OSM Hotels（酒店 points)*

-   `st_intersects(A, B)` - Do A (boroughs) touch or overlap with B (OSM).

    -   Returns a list of boroughs (33 rows) and in each borough a list of hotels

-   `st_contains(A, B)` - Does A (boroughs) contain B (OSM)

    -   Returns a list of boroughs (33 rows) and in each borough a list of hotels

-   `st_within(A, B)` - Is A (boroughs) inside B (OSM). This is asking are boroughs inside hotels

    -   Returns a list of boroughs that are inside hotels, this produces a result of 0. If we flip it we get a result but it will be the length of the hotels (e.g. `st_within(OSM, Londonborough)`). Note, `st_within(A, B) == st_contains(B, A)`

```{r}
Hotels_example <-st_contains(Londonborough, OSM)
#問每個borough完全包含哪啲酒店points

Hotels_example
```

This output has resulted 33 rows (32 boroughs and 1 City of London)!!

e.g. 1 is the first borough in Londonbrough and the 35, 105... are the row indices of hotel points in OSM that are contained inside that first borough!!

#### The Actual Code:

Now we take the length of that list per borough:

```{r}
Accomodation_contained <- Londonborough%>%
  mutate(hotels_n = lengths(st_contains(., OSM)))%>%
  # lengths() - turns list of indices (35, 105...) from st_contains to a numeric vector: number of hotels per borough
  # st_contains - topological predicate that ask for each borough polygon in which points in OSM are strictly contained inside it.
  mutate(airbnbs_n = lengths(st_contains(., Airbnbs)))
```

Now Bexley is 0 hotels not 1 !! Woohoo!!

#### Check our Bexley Example

It should be 0 hotels not 1!!

```{r}
# the group by and summarise data = 1 Hotel!
Accomodation_contained %>%
  filter(NAME=="Bexley")
```

### Key Advice

Find out whether it is Point or Multipolygon?

-   When you run the code to load in the data, it tells you in the **Geometry Type: ...**

OK, so, when to use `st_join()` or a topological relationship??

`st_join()`

-   joins attributes of two spatial objects

-   e.g. if I wanted to know what borough each hotel was in…the output here would be points (each hotel row now **carries the borough’s fields** (name, code, etc.) as the first dataset is point)

```{r}
Hotels2 <-  st_join(OSM, Londonborough)
```

-   It can easily join polygons or points of the same exact geometry (e.g. if i had data in two sf objects for London)

```{r}
London_data <-  st_join(London_borough_data1, London_borough_data2, join=st_equals)
```

**Topological Relationships**

-   Use when you just need counts / relationships, not extra columns

-   e.g. when you want to know "***How many points are in each polygon***?"

-   Create counts of points in polygons but without knowing what borough each hotel is in. It returns the borough polygons with a count.

## 5.9. Mapping
